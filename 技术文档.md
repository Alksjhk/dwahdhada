# 网页聊天系统技术文档

## 一、项目概述

### 1.1 项目名称
轻量级网页聊天系统（Web Chat System）

### 1.2 项目目标
开发一个无需注册登录的轻量级网页聊天系统，支持公共聊天室和私密房间功能，通过HTTP轮询实现实时消息推送。

### 1.3 技术特点
- 无用户注册流程，使用自定义ID快速接入
- 6位数字房间号系统，支持私密聊天
- HTTP轮询机制实现消息实时性（1秒间隔）
- SQLite轻量级数据库存储
- React + Node.js 全栈架构
- 支持文件上传（图片、文档等，最大10MB）
- 数据库自动迁移机制
- TypeScript全栈类型安全

### 1.4 项目状态
✅ **已完成并投入使用**
- 核心聊天功能完整实现
- 文件上传功能正常
- 数据库结构稳定
- 前后端API对接完成
- 响应式UI适配完成

---

## 二、系统架构设计

### 2.1 整体架构图
```
┌─────────────────────────────────────────┐
│           前端 (React)                   │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐ │
│  │登录表单 │  │聊天界面 │  │轮询组件 │ │
│  └─────────┘  └─────────┘  └─────────┘ │
└────────────────┬────────────────────────┘
                 │ HTTP/JSON
┌────────────────▼────────────────────────┐
│        后端 (Express + Node.js)         │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐ │
│  │路由处理 │  │业务逻辑 │  │数据库层 │ │
│  └─────────┘  └─────────┘  └─────────┘ │
└────────────────┬────────────────────────┘
                 │ SQL
┌────────────────▼────────────────────────┐
│          数据库 (SQLite3)               │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐ │
│  │ users   │  │ rooms   │  │messages │ │
│  └─────────┘  └─────────┘  └─────────┘ │
└─────────────────────────────────────────┘
```

### 2.2 技术栈详情

#### 前端技术栈
| 技术 | 版本 | 用途 |
|------|------|------|
| React | 18.x | UI框架 |
| TypeScript | 5.x | 类型系统 |
| Axios | 1.x | HTTP客户端 |
| Vite/Webpack | - | 构建工具 |
| CSS Modules | - | 样式管理 |

#### 后端技术栈
| 技术 | 版本 | 用途 |
|------|------|------|
| Node.js | 18.x/20.x | 运行时环境 |
| Express | 4.x | Web框架 |
| SQLite3 | 5.x | 数据库 |
| CORS | 2.x | 跨域中间件 |

---

## 三、数据库设计

### 3.1 数据库ER图
```
users (用户表)
├── id (PK)
├── user_id (UNIQUE)
└── created_at

rooms (房间表)
├── id (PK)
├── room_code (UNIQUE, 6位数字)
├── room_name
├── created_by
├── created_at
└── is_public

messages (消息表)
├── id (PK)
├── room_id (FK → rooms.id)
├── user_id
├── content
└── created_at
```

### 3.2 表结构详细说明

#### users 表
```sql
CREATE TABLE users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id TEXT UNIQUE NOT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);
```

**字段说明：**
- `id`: 自增主键
- `user_id`: 用户自定义ID（唯一标识）
- `created_at`: 创建时间

**索引：**
```sql
CREATE INDEX idx_users_user_id ON users(user_id);
```

#### rooms 表
```sql
CREATE TABLE rooms (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    room_code CHAR(6) UNIQUE NOT NULL,
    room_name TEXT DEFAULT '私密房间',
    created_by TEXT,
    admin_users TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    is_public BOOLEAN DEFAULT 0
);
```

**字段说明：**
- `id`: 自增主键
- `room_code`: 6位数字房间号
- `room_name`: 房间名称
- `created_by`: 创建者user_id
- `admin_users`: 管理员列表（JSON格式）
- `is_public`: 是否为公共大厅（0=私密，1=公共）

**特殊约定：**
- 公共大厅房间号固定为 "PUBLIC"，id = 0
- 公共大厅 is_public = 1

#### user_status 表
```sql
CREATE TABLE user_status (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id TEXT UNIQUE NOT NULL,
    room_id INTEGER,
    is_online BOOLEAN DEFAULT 0,
    last_seen DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (room_id) REFERENCES rooms(id)
);
```

**字段说明：**
- `id`: 自增主键
- `user_id`: 用户ID
- `room_id`: 当前所在房间
- `is_online`: 是否在线
- `last_seen`: 最后活跃时间

#### messages 表
```sql
CREATE TABLE messages (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    room_id INTEGER NOT NULL,
    user_id TEXT NOT NULL,
    content TEXT NOT NULL,
    message_type TEXT DEFAULT 'text',
    file_name TEXT,
    file_size INTEGER,
    file_url TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (room_id) REFERENCES rooms(id)
);
```

**字段说明：**
- `id`: 自增主键（用于轮询增量获取）
- `room_id`: 房间ID
- `user_id`: 发送者ID
- `content`: 消息内容
- `message_type`: 消息类型（text/image/file）
- `file_name`: 文件名
- `file_size`: 文件大小
- `file_url`: 文件URL
- `created_at`: 发送时间

**索引：**
```sql
CREATE INDEX idx_messages_room_id ON messages(room_id);
CREATE INDEX idx_messages_created_at ON messages(created_at);
```

---

## 四、API接口规范

### 4.1 基础配置
- **Base URL**: `/api`
- **数据格式**: JSON
- **字符编码**: UTF-8
- **跨域**: 支持

### 4.2 房间管理接口

#### 1) 获取公共大厅信息
**GET** `/api/rooms/public`

**请求示例：**
```http
GET /api/rooms/public
```

**响应示例：**
```json
{
    "success": true,
    "roomId": 0,
    "roomName": "公共大厅"
}
```

---

#### 2) 创建私密房间
**POST** `/api/rooms/create`

**请求体：**
```json
{
    "roomCode": "123456",
    "userId": "user123"
}
```

**响应示例（成功）：**
```json
{
    "success": true,
    "roomId": 1,
    "roomName": "私密房间"
}
```

**响应示例（房间已存在）：**
```json
{
    "success": false,
    "message": "房间已存在"
}
```

**响应示例（房间号格式错误）：**
```json
{
    "success": false,
    "message": "房间号必须是6位数字"
}
```

---

#### 3) 加入房间
**GET** `/api/rooms/join/:roomCode`

**请求示例：**
```http
GET /api/rooms/join/123456
```

**响应示例（成功）：**
```json
{
    "success": true,
    "roomId": 1,
    "roomName": "私密房间"
}
```

**响应示例（房间不存在）：**
```json
{
    "success": false,
    "message": "房间不存在"
}
```

---

### 4.3 消息管理接口

#### 1) 发送消息
**POST** `/api/messages/send`

**请求体：**
```json
{
    "roomId": 1,
    "userId": "user123",
    "content": "Hello World"
}
```

**约束条件：**
- `content` 长度限制：1-500字符
- `roomId` 必须为有效房间ID

**响应示例（成功）：**
```json
{
    "success": true,
    "messageId": 101
}
```

**响应示例（失败）：**
```json
{
    "success": false,
    "message": "消息内容不能为空"
}
```

---

#### 2) 获取最新消息（初始加载）
**GET** `/api/messages/:roomId/latest`

**请求示例：**
```http
GET /api/messages/1/latest
```

**响应示例：**
```json
{
    "success": true,
    "messages": [
        {
            "id": 99,
            "userId": "user123",
            "content": "Earlier message",
            "messageType": "text",
            "createdAt": "2024-01-01 11:55:00"
        },
        {
            "id": 100,
            "userId": "user456",
            "content": "Latest message",
            "messageType": "text",
            "createdAt": "2024-01-01 12:00:00"
        }
    ]
}
```

---

#### 3) 获取房间消息（轮询接口）
**GET** `/api/messages/:roomId`

**查询参数：**
- `lastMessageId` (可选): 客户端最后一条消息ID

**请求示例：**
```http
GET /api/messages/1?lastMessageId=100
```

**响应示例（有新消息）：**
```json
{
    "success": true,
    "hasNew": true,
    "messages": [
        {
            "id": 101,
            "userId": "user123",
            "content": "Hello",
            "messageType": "text",
            "createdAt": "2024-01-01 12:00:00"
        },
        {
            "id": 102,
            "userId": "user456",
            "content": "Hi!",
            "messageType": "text",
            "createdAt": "2024-01-01 12:00:05"
        }
    ]
}
```

**响应示例（无新消息）：**
```json
{
    "success": true,
    "hasNew": false,
    "messages": []
}
```

---

### 4.4 文件管理接口

#### 1) 上传文件
**POST** `/api/files/upload`

**请求：** multipart/form-data
- `file`: 文件数据

**响应示例：**
```json
{
    "success": true,
    "fileUrl": "/uploads/1703654400000-filename.jpg",
    "fileName": "filename.jpg",
    "fileSize": 102400
}
```

---

#### 2) 下载文件
**GET** `/api/files/:filename`

**请求示例：**
```http
GET /api/files/1703654400000-filename.jpg
```

**响应：** 文件二进制数据

---

## 五、前端架构设计

### 5.1 组件结构
```
App
├── LoginForm (登录表单组件)
│   ├── ID输入框
│   ├── 提交按钮
│   └── 错误提示
│
└── ChatContainer (聊天主容器)
    ├── RoomSelector (房间选择器)
    │   ├── 公共大厅按钮
    │   ├── 房间号输入框
    │   ├── 创建/加入按钮
    │   └── 当前房间信息
    │
    ├── MessageList (消息列表)
    │   ├── 消息容器
    │   ├── 单条消息组件
    │   └── 滚动定位
    │
    ├── MessageInput (消息输入)
    │   ├── 文本输入框
    │   ├── 发送按钮
    │   └── 快捷键支持(Enter)
    │
    └── OnlineUsers (在线用户 - 可选)
        ├── 用户列表
        └── 在线状态
```

### 5.2 TypeScript 类型定义

```typescript
// 应用状态
interface AppState {
    currentUser: string;      // 当前用户ID
    currentRoom: Room;        // 当前房间
    messages: Message[];      // 消息列表
    rooms: Room[];            // 已加入房间列表
    isConnected: boolean;     // 连接状态
    isLoading: boolean;       // 加载状态
}

// 房间类型
interface Room {
    id: number;              // 房间ID
    name: string;            // 房间名称
    code?: string;           // 房间号（私密房间）
    isPublic: boolean;       // 是否公共大厅
}

// 消息类型
interface Message {
    id: number;              // 消息ID
    userId: string;          // 发送者ID
    content: string;         // 消息内容
    createdAt: string;       // 创建时间
}

// API响应类型
interface ApiResponse<T = any> {
    success: boolean;
    message?: string;
    data?: T;
}

interface MessagesResponse {
    success: boolean;
    hasNew: boolean;
    messages: Message[];
}
```

### 5.3 状态管理方案

#### 使用 React Context + useReducer

```typescript
// Action 类型
type ChatAction =
    | { type: 'SET_USER'; payload: string }
    | { type: 'SET_ROOM'; payload: Room }
    | { type: 'ADD_MESSAGES'; payload: Message[] }
    | { type: 'SEND_MESSAGE'; payload: Message }
    | { type: 'SET_LOADING'; payload: boolean };

// Reducer
function chatReducer(state: AppState, action: ChatAction): AppState {
    switch (action.type) {
        case 'SET_USER':
            return { ...state, currentUser: action.payload };
        case 'SET_ROOM':
            return { ...state, currentRoom: action.payload, messages: [] };
        case 'ADD_MESSAGES':
            return {
                ...state,
                messages: [...state.messages, ...action.payload]
            };
        case 'SEND_MESSAGE':
            return {
                ...state,
                messages: [...state.messages, action.payload]
            };
        case 'SET_LOADING':
            return { ...state, isLoading: action.payload };
        default:
            return state;
    }
}
```

---

## 六、核心业务逻辑

### 6.1 消息轮询机制

#### 轮询类实现
```typescript
class MessagePoller {
    private roomId: number;
    private lastMessageId: number;
    private pollInterval: number;
    private pollTimer: NodeJS.Timeout | null;
    private onNewMessages: (messages: Message[]) => void;
    private isPolling: boolean;

    constructor(roomId: number, onNewMessages: (messages: Message[]) => void) {
        this.roomId = roomId;
        this.lastMessageId = 0;
        this.pollInterval = 1000; // 1秒轮询间隔
        this.pollTimer = null;
        this.onNewMessages = onNewMessages;
        this.isPolling = false;
    }

    start() {
        if (this.isPolling) return;

        this.isPolling = true;
        this.pollTimer = setInterval(() => {
            this.fetchMessages();
        }, this.pollInterval);

        // 立即执行一次
        this.fetchMessages();
    }

    stop() {
        if (this.pollTimer) {
            clearInterval(this.pollTimer);
            this.pollTimer = null;
        }
        this.isPolling = false;
    }

    updateRoomId(newRoomId: number) {
        this.stop();
        this.roomId = newRoomId;
        this.lastMessageId = 0;
        this.start();
    }

    private async fetchMessages() {
        try {
            const response = await fetch(
                `/api/messages/${this.roomId}?lastMessageId=${this.lastMessageId}`
            );
            const data: MessagesResponse = await response.json();

            if (data.success && data.hasNew && data.messages.length > 0) {
                this.lastMessageId = data.messages[data.messages.length - 1].id;
                this.onNewMessages(data.messages);
            }
        } catch (error) {
            console.error('轮询错误:', error);
        }
    }

    destroy() {
        this.stop();
    }
}
```

#### 使用示例
```typescript
// 在组件中使用
const ChatComponent: React.FC = () => {
    const [messages, setMessages] = useState<Message[]>([]);
    const pollerRef = useRef<MessagePoller | null>(null);

    useEffect(() => {
        pollerRef.current = new MessagePoller(roomId, (newMessages) => {
            setMessages(prev => [...prev, ...newMessages]);
        });
        pollerRef.current.start();

        return () => {
            pollerRef.current?.destroy();
        };
    }, [roomId]);

    // 发送消息后立即轮询一次
    const handleSendMessage = async (content: string) => {
        await sendMessage(roomId, currentUser, content);
        pollerRef.current?.fetchMessages(); // 立即获取最新消息
    };
};
```

### 6.2 房间管理逻辑

#### 房间号验证
```typescript
function validateRoomCode(code: string): boolean {
    return /^\d{6}$/.test(code);
}

function formatRoomCode(code: string): string {
    return code.padStart(6, '0');
}
```

#### 房间切换流程
```typescript
async function switchRoom(roomCode: string | null, userId: string) {
    try {
        let roomData;

        if (roomCode === null) {
            // 切换到公共大厅
            const response = await fetch('/api/rooms/public');
            roomData = await response.json();
        } else {
            // 尝试加入私密房间
            const response = await fetch(`/api/rooms/join/${roomCode}`);
            const data = await response.json();

            if (!data.success) {
                // 房间不存在，尝试创建
                const createResponse = await fetch('/api/rooms/create', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ roomCode, userId })
                });
                roomData = await createResponse.json();
            } else {
                roomData = data;
            }
        }

        return {
            id: roomData.roomId,
            name: roomData.roomName,
            code: roomCode,
            isPublic: roomCode === null
        };
    } catch (error) {
        console.error('切换房间失败:', error);
        throw error;
    }
}
```

### 6.3 消息发送流程

```typescript
async function sendMessage(
    roomId: number,
    userId: string,
    content: string
): Promise<boolean> {
    // 前端验证
    if (!content.trim()) {
        alert('消息内容不能为空');
        return false;
    }

    if (content.length > 500) {
        alert('消息内容不能超过500字符');
        return false;
    }

    try {
        const response = await fetch('/api/messages/send', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                roomId,
                userId,
                content: content.trim()
            })
        });

        const data = await response.json();

        if (!data.success) {
            alert(data.message || '发送失败');
            return false;
        }

        return true;
    } catch (error) {
        console.error('发送消息失败:', error);
        alert('网络错误，请重试');
        return false;
    }
}
```

---

## 七、后端实现规范

### 7.1 项目目录结构
```
server/
├── src/
│   ├── config/
│   │   └── database.ts          # 数据库配置
│   ├── controllers/
│   │   ├── roomController.ts    # 房间控制器
│   │   └── messageController.ts # 消息控制器
│   ├── routes/
│   │   ├── roomRoutes.ts        # 房间路由
│   │   └── messageRoutes.ts     # 消息路由
│   ├── models/
│   │   ├── userModel.ts         # 用户模型
│   │   ├── roomModel.ts         # 房间模型
│   │   └── messageModel.ts      # 消息模型
│   ├── middleware/
│   │   ├── validation.ts        # 验证中间件
│   │   └── errorHandler.ts      # 错误处理
│   ├── utils/
│   │   └── database.ts          # 数据库工具
│   └── app.ts                   # 应用入口
├── database/
│   └── chat.db                  # SQLite数据库文件
├── .env                         # 环境变量
├── package.json
└── tsconfig.json
```

### 7.2 数据库初始化脚本

```typescript
// database/init.ts
import sqlite3 from 'sqlite3';

export function initializeDatabase(dbPath: string): Promise<void> {
    return new Promise((resolve, reject) => {
        const db = new sqlite3.Database(dbPath, (err) => {
            if (err) {
                reject(err);
                return;
            }
        });

        // 创建用户表
        db.run(`
            CREATE TABLE IF NOT EXISTS users (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id TEXT UNIQUE NOT NULL,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        `);

        // 创建房间表
        db.run(`
            CREATE TABLE IF NOT EXISTS rooms (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                room_code CHAR(6) UNIQUE NOT NULL,
                room_name TEXT DEFAULT '私密房间',
                created_by TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                is_public BOOLEAN DEFAULT 0
            )
        `);

        // 创建消息表
        db.run(`
            CREATE TABLE IF NOT EXISTS messages (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                room_id INTEGER NOT NULL,
                user_id TEXT NOT NULL,
                content TEXT NOT NULL,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (room_id) REFERENCES rooms(id)
            )
        `);

        // 创建公共大厅（如果不存在）
        db.run(`
            INSERT OR IGNORE INTO rooms (room_code, room_name, is_public)
            VALUES ('PUBLIC', '公共大厅', 1)
        `, () => {
            db.close();
            resolve();
        });
    });
}
```

### 7.3 核心控制器实现

#### 房间控制器
```typescript
// controllers/roomController.ts
import { Request, Response } from 'express';
import db from '../utils/database';

export class RoomController {
    // 获取公共大厅
    async getPublicRoom(req: Request, res: Response) {
        try {
            res.json({
                success: true,
                roomId: 0,
                roomName: '公共大厅'
            });
        } catch (error) {
            res.status(500).json({ success: false, message: '服务器错误' });
        }
    }

    // 创建房间
    async createRoom(req: Request, res: Response) {
        const { roomCode, userId } = req.body;

        // 验证
        if (!/^\d{6}$/.test(roomCode)) {
            return res.json({
                success: false,
                message: '房间号必须是6位数字'
            });
        }

        try {
            // 检查房间是否已存在
            const existing = await db.get(
                'SELECT id FROM rooms WHERE room_code = ?',
                [roomCode]
            );

            if (existing) {
                return res.json({
                    success: false,
                    message: '房间已存在'
                });
            }

            // 创建房间
            const result = await db.run(
                'INSERT INTO rooms (room_code, created_by) VALUES (?, ?)',
                [roomCode, userId]
            );

            res.json({
                success: true,
                roomId: result.lastID,
                roomName: '私密房间'
            });
        } catch (error) {
            res.status(500).json({ success: false, message: '服务器错误' });
        }
    }

    // 加入房间
    async joinRoom(req: Request, res: Response) {
        const { roomCode } = req.params;

        try {
            const room = await db.get(
                'SELECT id, room_name FROM rooms WHERE room_code = ?',
                [roomCode]
            );

            if (!room) {
                return res.json({
                    success: false,
                    message: '房间不存在'
                });
            }

            res.json({
                success: true,
                roomId: room.id,
                roomName: room.room_name
            });
        } catch (error) {
            res.status(500).json({ success: false, message: '服务器错误' });
        }
    }
}
```

#### 消息控制器
```typescript
// controllers/messageController.ts
import { Request, Response } from 'express';
import db from '../utils/database';

export class MessageController {
    // 发送消息
    async sendMessage(req: Request, res: Response) {
        const { roomId, userId, content } = req.body;

        // 验证
        if (!content || !content.trim()) {
            return res.json({
                success: false,
                message: '消息内容不能为空'
            });
        }

        if (content.length > 500) {
            return res.json({
                success: false,
                message: '消息内容不能超过500字符'
            });
        }

        try {
            // 验证房间存在（公共大厅roomId=0跳过验证）
            if (roomId !== 0) {
                const room = await db.get('SELECT id FROM rooms WHERE id = ?', [roomId]);
                if (!room) {
                    return res.json({
                        success: false,
                        message: '房间不存在'
                    });
                }
            }

            // 插入消息
            const result = await db.run(
                'INSERT INTO messages (room_id, user_id, content) VALUES (?, ?, ?)',
                [roomId, userId, content.trim()]
            );

            res.json({
                success: true,
                messageId: result.lastID
            });
        } catch (error) {
            res.status(500).json({ success: false, message: '服务器错误' });
        }
    }

    // 获取消息（轮询接口）
    async getMessages(req: Request, res: Response) {
        const roomId = parseInt(req.params.roomId);
        const lastMessageId = parseInt(req.query.lastMessageId as string) || 0;

        try {
            // 获取新消息
            const messages = await db.all(
                `SELECT id, user_id as userId, content, created_at as createdAt
                 FROM messages
                 WHERE room_id = ? AND id > ?
                 ORDER BY id ASC`,
                [roomId, lastMessageId]
            );

            res.json({
                success: true,
                hasNew: messages.length > 0,
                messages: messages
            });
        } catch (error) {
            res.status(500).json({ success: false, message: '服务器错误' });
        }
    }
}
```

### 7.4 路由配置

```typescript
// routes/roomRoutes.ts
import { Router } from 'express';
import { RoomController } from '../controllers/roomController';

const router = Router();
const controller = new RoomController();

router.get('/public', controller.getPublicRoom);
router.post('/create', controller.createRoom);
router.get('/join/:roomCode', controller.joinRoom);

export default router;

// routes/messageRoutes.ts
import { Router } from 'express';
import { MessageController } from '../controllers/messageController';

const router = Router();
const controller = new MessageController();

router.post('/send', controller.sendMessage);
router.get('/:roomId', controller.getMessages);

export default router;

// app.ts (主应用)
import express from 'express';
import cors from 'cors';
import roomRoutes from './routes/roomRoutes';
import messageRoutes from './routes/messageRoutes';
import { initializeDatabase } from './database/init';

const app = express();
const PORT = process.env.PORT || 3001;

// 中间件
app.use(cors());
app.use(express.json());

// 路由
app.use('/api/rooms', roomRoutes);
app.use('/api/messages', messageRoutes);

// 初始化数据库并启动
initializeDatabase(process.env.DATABASE_PATH || './database/chat.db')
    .then(() => {
        app.listen(PORT, () => {
            console.log(`服务器运行在 http://localhost:${PORT}`);
        });
    })
    .catch(err => {
        console.error('数据库初始化失败:', err);
    });
```

---

## 八、前端组件实现示例

### 8.1 主应用组件

```typescript
// App.tsx
import React, { useState, useEffect, useRef } from 'react';
import LoginForm from './components/LoginForm';
import ChatContainer from './components/ChatContainer';
import { MessagePoller } from './utils/MessagePoller';
import { AppState, Room, Message } from './types';
import styles from './App.module.css';

const App: React.FC = () => {
    const [appState, setAppState] = useState<AppState>({
        currentUser: '',
        currentRoom: { id: 0, name: '公共大厅', isPublic: true },
        messages: [],
        rooms: [],
        isConnected: false,
        isLoading: false
    });

    const pollerRef = useRef<MessagePoller | null>(null);

    // 从localStorage恢复用户ID
    useEffect(() => {
        const savedUserId = localStorage.getItem('chat_user_id');
        if (savedUserId) {
            setAppState(prev => ({
                ...prev,
                currentUser: savedUserId,
                isConnected: true
            }));
        }
    }, []);

    // 处理用户登录
    const handleLogin = (userId: string) => {
        localStorage.setItem('chat_user_id', userId);
        setAppState(prev => ({
            ...prev,
            currentUser: userId,
            isConnected: true
        }));
    };

    // 处理房间切换
    const handleRoomChange = async (room: Room) => {
        setAppState(prev => ({
            ...prev,
            currentRoom: room,
            messages: [],
            isLoading: true
        }));

        // 停止旧轮询
        if (pollerRef.current) {
            pollerRef.current.destroy();
        }

        // 启动新轮询
        pollerRef.current = new MessagePoller(room.id, (newMessages) => {
            setAppState(prev => ({
                ...prev,
                messages: [...prev.messages, ...newMessages]
            }));
        });
        pollerRef.current.start();

        setAppState(prev => ({ ...prev, isLoading: false }));
    };

    // 发送消息
    const handleSendMessage = async (content: string) => {
        try {
            const response = await fetch('/api/messages/send', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    roomId: appState.currentRoom.id,
                    userId: appState.currentUser,
                    content
                })
            });

            const data = await response.json();

            if (data.success && pollerRef.current) {
                // 立即轮询获取最新消息
                setTimeout(() => {
                    (pollerRef.current as any).fetchMessages();
                }, 100);
            }
        } catch (error) {
            console.error('发送失败:', error);
        }
    };

    // 清理
    useEffect(() => {
        return () => {
            if (pollerRef.current) {
                pollerRef.current.destroy();
            }
        };
    }, []);

    if (!appState.isConnected) {
        return (
            <div className={styles.app}>
                <LoginForm onLogin={handleLogin} />
            </div>
        );
    }

    return (
        <div className={styles.app}>
            <ChatContainer
                currentUser={appState.currentUser}
                currentRoom={appState.currentRoom}
                messages={appState.messages}
                isLoading={appState.isLoading}
                onRoomChange={handleRoomChange}
                onSendMessage={handleSendMessage}
            />
        </div>
    );
};

export default App;
```

### 8.2 聊天容器组件

```typescript
// components/ChatContainer.tsx
import React from 'react';
import RoomSelector from './RoomSelector';
import MessageList from './MessageList';
import MessageInput from './MessageInput';
import { Room, Message } from '../types';
import styles from './ChatContainer.module.css';

interface ChatContainerProps {
    currentUser: string;
    currentRoom: Room;
    messages: Message[];
    isLoading: boolean;
    onRoomChange: (room: Room) => void;
    onSendMessage: (content: string) => void;
}

const ChatContainer: React.FC<ChatContainerProps> = ({
    currentUser,
    currentRoom,
    messages,
    isLoading,
    onRoomChange,
    onSendMessage
}) => {
    return (
        <div className={styles.container}>
            <div className={styles.header}>
                <h2>{currentRoom.name}</h2>
                <span className={styles.userBadge}>{currentUser}</span>
            </div>

            <RoomSelector
                currentRoom={currentRoom}
                onRoomChange={onRoomChange}
            />

            <MessageList
                messages={messages}
                isLoading={isLoading}
                currentUser={currentUser}
            />

            <MessageInput
                onSendMessage={onSendMessage}
                disabled={isLoading}
            />
        </div>
    );
};

export default ChatContainer;
```

### 8.3 房间选择器组件

```typescript
// components/RoomSelector.tsx
import React, { useState } from 'react';
import { Room } from '../types';
import styles from './RoomSelector.module.css';

interface RoomSelectorProps {
    currentRoom: Room;
    onRoomChange: (room: Room) => void;
}

const RoomSelector: React.FC<RoomSelectorProps> = ({
    currentRoom,
    onRoomChange
}) => {
    const [roomCode, setRoomCode] = useState('');
    const [error, setError] = useState('');

    const handlePublicRoom = () => {
        onRoomChange({
            id: 0,
            name: '公共大厅',
            isPublic: true
        });
    };

    const handleJoinOrCreate = async () => {
        setError('');

        // 验证格式
        if (!/^\d{6}$/.test(roomCode)) {
            setError('房间号必须是6位数字');
            return;
        }

        try {
            // 先尝试加入
            const joinResponse = await fetch(`/api/rooms/join/${roomCode}`);
            const joinData = await joinResponse.json();

            if (joinData.success) {
                onRoomChange({
                    id: joinData.roomId,
                    name: joinData.roomName,
                    code: roomCode,
                    isPublic: false
                });
                setRoomCode('');
                return;
            }

            // 房间不存在，尝试创建
            const createResponse = await fetch('/api/rooms/create', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    roomCode,
                    userId: localStorage.getItem('chat_user_id') || 'unknown'
                })
            });

            const createData = await createResponse.json();

            if (createData.success) {
                onRoomChange({
                    id: createData.roomId,
                    name: createData.roomName,
                    code: roomCode,
                    isPublic: false
                });
                setRoomCode('');
            } else {
                setError(createData.message || '操作失败');
            }
        } catch (err) {
            setError('网络错误，请重试');
        }
    };

    return (
        <div className={styles.selector}>
            <div className={styles.buttons}>
                <button
                    onClick={handlePublicRoom}
                    className={currentRoom.isPublic ? styles.active : ''}
                >
                    公共大厅
                </button>
            </div>

            <div className={styles.roomInput}>
                <input
                    type="text"
                    value={roomCode}
                    onChange={(e) => setRoomCode(e.target.value)}
                    placeholder="输入6位房间号"
                    maxLength={6}
                    onKeyDown={(e) => {
                        if (e.key === 'Enter') handleJoinOrCreate();
                    }}
                />
                <button onClick={handleJoinOrCreate}>
                    {currentRoom.code === roomCode ? '切换' : '创建/加入'}
                </button>
            </div>

            {error && <div className={styles.error}>{error}</div>}

            {currentRoom.code && (
                <div className={styles.currentRoom}>
                    当前房间: <strong>{currentRoom.code}</strong>
                </div>
            )}
        </div>
    );
};

export default RoomSelector;
```

### 8.4 消息列表组件

```typescript
// components/MessageList.tsx
import React, { useEffect, useRef } from 'react';
import { Message } from '../types';
import styles from './MessageList.module.css';

interface MessageListProps {
    messages: Message[];
    isLoading: boolean;
    currentUser: string;
}

const MessageList: React.FC<MessageListProps> = ({
    messages,
    isLoading,
    currentUser
}) => {
    const messagesEndRef = useRef<HTMLDivElement>(null);

    // 自动滚动到底部
    useEffect(() => {
        messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
    }, [messages]);

    const formatTime = (timestamp: string) => {
        const date = new Date(timestamp);
        return date.toLocaleTimeString('zh-CN', {
            hour: '2-digit',
            minute: '2-digit'
        });
    };

    const isOwnMessage = (userId: string) => userId === currentUser;

    if (isLoading) {
        return (
            <div className={styles.container}>
                <div className={styles.loading}>加载中...</div>
            </div>
        );
    }

    if (messages.length === 0) {
        return (
            <div className={styles.container}>
                <div className={styles.empty}>暂无消息，发送第一条消息吧！</div>
            </div>
        );
    }

    return (
        <div className={styles.container}>
            <div className={styles.messages}>
                {messages.map((msg) => (
                    <div
                        key={msg.id}
                        className={`${styles.message} ${
                            isOwnMessage(msg.userId) ? styles.own : styles.other
                        }`}
                    >
                        <div className={styles.messageHeader}>
                            <span className={styles.userId}>{msg.userId}</span>
                            <span className={styles.time}>
                                {formatTime(msg.createdAt)}
                            </span>
                        </div>
                        <div className={styles.content}>{msg.content}</div>
                    </div>
                ))}
                <div ref={messagesEndRef} />
            </div>
        </div>
    );
};

export default MessageList;
```

### 8.5 消息输入组件

```typescript
// components/MessageInput.tsx
import React, { useState } from 'react';
import styles from './MessageInput.module.css';

interface MessageInputProps {
    onSendMessage: (content: string) => void;
    disabled?: boolean;
}

const MessageInput: React.FC<MessageInputProps> = ({
    onSendMessage,
    disabled = false
}) => {
    const [content, setContent] = useState('');

    const handleSend = () => {
        const trimmed = content.trim();
        if (!trimmed || disabled) return;

        onSendMessage(trimmed);
        setContent('');
    };

    const handleKeyDown = (e: React.KeyboardEvent) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            handleSend();
        }
    };

    return (
        <div className={styles.container}>
            <textarea
                value={content}
                onChange={(e) => setContent(e.target.value)}
                onKeyDown={handleKeyDown}
                placeholder="输入消息，按 Enter 发送"
                disabled={disabled}
                rows={3}
                maxLength={500}
            />
            <div className={styles.footer}>
                <span className={styles.counter}>
                    {content.length}/500
                </span>
                <button
                    onClick={handleSend}
                    disabled={!content.trim() || disabled}
                    className={styles.sendButton}
                >
                    发送
                </button>
            </div>
        </div>
    );
};

export default MessageInput;
```

---

## 九、样式规范

### 9.1 CSS Modules 命名规范
```css
/* 组件名.module.css */
.ComponentName {
    /* 组件根容器 */
}

.element {
    /* 子元素 */
}

.modifier {
    /* 修饰符，如 .button.active */
}

.state {
    /* 状态，如 .input.error */
}
```

### 9.2 颜色方案
```css
:root {
    --primary: #4A90E2;
    --primary-dark: #357ABD;
    --success: #52C41A;
    --warning: #FAAD14;
    --error: #F5222D;

    --bg-primary: #FFFFFF;
    --bg-secondary: #F5F5F5;
    --bg-dark: #1890FF;

    --text-primary: #333333;
    --text-secondary: #666666;
    --text-light: #FFFFFF;

    --border: #E8E8E8;
    --border-focus: #4A90E2;

    --shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    --shadow-hover: 0 4px 12px rgba(0, 0, 0, 0.2);
}
```

### 9.3 响应式设计
```css
/* 移动端优先 */
.container {
    width: 100%;
    max-width: 600px;
    margin: 0 auto;
}

/* 平板 */
@media (min-width: 768px) {
    .container {
        max-width: 800px;
    }
}

/* 桌面 */
@media (min-width: 1024px) {
    .container {
        max-width: 1000px;
    }
}
```

---

## 十、测试策略

### 10.1 单元测试

#### 后端测试
```typescript
// tests/roomController.test.ts
import request from 'supertest';
import app from '../src/app';

describe('Room Controller', () => {
    describe('POST /api/rooms/create', () => {
        it('应成功创建房间', async () => {
            const response = await request(app)
                .post('/api/rooms/create')
                .send({
                    roomCode: '999999',
                    userId: 'testUser'
                });

            expect(response.status).toBe(200);
            expect(response.body.success).toBe(true);
            expect(response.body.roomId).toBeDefined();
        });

        it('应拒绝无效的房间号', async () => {
            const response = await request(app)
                .post('/api/rooms/create')
                .send({
                    roomCode: '123',
                    userId: 'testUser'
                });

            expect(response.body.success).toBe(false);
        });
    });
});
```

#### 前端测试
```typescript
// tests/MessagePoller.test.ts
import { MessagePoller } from '../src/utils/MessagePoller';

describe('MessagePoller', () => {
    it('应正确轮询消息', async () => {
        const mockCallback = jest.fn();
        const poller = new MessagePoller(1, mockCallback);

        // Mock fetch
        global.fetch = jest.fn().mockResolvedValue({
            json: async () => ({
                success: true,
                hasNew: true,
                messages: [{ id: 1, userId: 'user1', content: 'test' }]
            })
        });

        poller.start();

        await new Promise(resolve => setTimeout(resolve, 2100));

        expect(mockCallback).toHaveBeenCalled();

        poller.destroy();
    });
});
```

### 10.2 集成测试
测试完整用户流程：
1. 用户登录
2. 创建房间
3. 发送消息
4. 轮询获取消息
5. 切换房间

### 10.3 性能测试
- 轮询并发测试（100+用户同时在线）
- 消息发送频率限制测试
- 数据库查询性能测试

---

## 十一、部署指南

### 11.1 环境要求
- Node.js >= 18.0.0
- npm >= 9.0.0 或 yarn >= 1.22.0
- 系统：Windows/Linux/macOS

### 11.2 部署步骤

#### 1) 后端部署
```bash
# 进入服务器目录
cd server

# 安装依赖
npm install

# 配置环境变量
cp .env.example .env
# 编辑 .env 文件

# 构建（如果使用TypeScript）
npm run build

# 启动
npm start

# 或使用PM2守护进程
npm install -g pm2
pm2 start dist/app.js --name chat-server
```

#### 2) 前端部署
```bash
# 进入客户端目录
cd client

# 安装依赖
npm install

# 配置API地址
# 编辑 .env 或 src/config.ts

# 构建
npm run build

# 部署到Web服务器
# 将 build/ 目录内容部署到 Nginx/Apache
```

#### 3) Nginx 配置示例
```nginx
server {
    listen 80;
    server_name your-domain.com;

    # 前端静态文件
    location / {
        root /var/www/chat-app/client/build;
        index index.html;
        try_files $uri $uri/ /index.html;
    }

    # API代理
    location /api/ {
        proxy_pass http://localhost:3001;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }
}
```

### 11.3 生产环境优化

#### 数据库优化
```sql
-- 定期清理旧消息（建议保留最近30天）
DELETE FROM messages
WHERE created_at < datetime('now', '-30 days');

-- 优化数据库
VACUUM;
ANALYZE;
```

#### 性能优化
```typescript
// 启用HTTP压缩
import compression from 'compression';
app.use(compression());

// 请求限流
import rateLimit from 'express-rate-limit';
const limiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15分钟
    max: 100 // 每个IP最多100次请求
});
app.use('/api/', limiter);
```

---

## 十二、监控与维护

### 12.1 日志记录
```typescript
// middleware/logger.ts
import { Request, Response, NextFunction } from 'express';

export function logger(req: Request, res: Response, next: NextFunction) {
    const start = Date.now();

    res.on('finish', () => {
        const duration = Date.now() - start;
        console.log(
            `[${new Date().toISOString()}] ${req.method} ${req.path} - ${res.statusCode} (${duration}ms)`
        );
    });

    next();
}
```

### 12.2 健康检查
```typescript
// GET /api/health
app.get('/api/health', (req, res) => {
    res.json({
        status: 'ok',
        timestamp: new Date().toISOString(),
        uptime: process.uptime()
    });
});
```

### 12.3 备份策略
```bash
# 每日备份脚本
#!/bin/bash
DATE=$(date +%Y%m%d)
BACKUP_DIR="/backups/chat-app"

mkdir -p $BACKUP_DIR
cp ./database/chat.db $BACKUP_DIR/chat-$DATE.db

# 保留最近7天
find $BACKUP_DIR -name "chat-*.db" -mtime +7 -delete
```

---

## 十三、常见问题

### Q1: 轮询频率如何选择？
**A:** 默认2秒，可根据服务器负载调整：
- 低负载：1-2秒（实时性好）
- 高负载：3-5秒（节省资源）

### Q2: 如何处理消息丢失？
**A:**
1. 使用消息ID增量获取
2. 客户端缓存最后N条消息
3. 发送失败重试机制

### Q3: 如何限制恶意用户？
**A:**
1. 限制单IP请求频率
2. 限制单用户消息发送频率
3. 消息内容长度和类型验证
4. 定期清理异常数据

### Q4: 如何扩展到多服务器？
**A:**
1. 使用Redis共享会话
2. 消息队列（RabbitMQ/Kafka）
3. 数据库读写分离
4. 负载均衡

---

## 十四、版本控制建议

### Git 提交规范
```
feat: 新功能
fix: 修复bug
docs: 文档更新
style: 代码格式
refactor: 重构
test: 测试相关
chore: 构建/工具变动
```

### 分支管理
```
main        # 生产环境
├── develop # 开发环境
│   ├── feature/login     # 功能分支
│   ├── feature/room-chat
│   └── hotfix/bug-001    # 紧急修复
```

---

## 十五、附录

### A. API速查表
| 接口 | 方法 | 说明 |
|------|------|------|
| `/api/rooms/public` | GET | 获取公共大厅 |
| `/api/rooms/create` | POST | 创建房间 |
| `/api/rooms/join/:code` | GET | 加入房间 |
| `/api/messages/send` | POST | 发送消息 |
| `/api/messages/:roomId` | GET | 获取消息（轮询） |

### B. 数据库速查表
| 表名 | 主要字段 | 说明 |
|------|----------|------|
| users | id, user_id | 用户表 |
| rooms | id, room_code, is_public | 房间表 |
| messages | id, room_id, user_id, content | 消息表 |

### C. 错误码参考
| 错误码 | 含义 |
|--------|------|
| 200 | 成功 |
| 400 | 请求参数错误 |
| 404 | 资源不存在 |
| 500 | 服务器内部错误 |

---

**文档版本**: v1.1
**最后更新**: 2025-12-27
**维护者**: 开发团队
